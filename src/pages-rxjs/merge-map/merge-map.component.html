<div class="page-header">
  <h1 class="title">MergeMap</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/mergeMap" target="_blank">rxjs mergeMap ‚û°Ô∏è</a>
</div>

<p>
  Este operador coge cada uno de los elementos emitidos por un Observable fuente y devuelve un nuevo Observable por
  cada elemento, cuyos elementos emitidos ser√°n puestos de nuevo en el observable fuente y que ser√°n los que se entregen
  al subscriptor.
</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable, mergeMap } from 'rxjs';

// This is the source observable
const numbers$ = new Observable<number>((observer) => {
  observer.next(1);
  observer.next(2);
  observer.next(0);
  observer.next(3);
});

// Use the pipe method to add operators
numbers$
  .pipe(
    mergeMap(
      (number) =>
        new Observable((observer) => {
          if (number === 0) {
            setTimeout(() => {
              observer.error('No existences');
            }, 1000);
          } else if (number == 1) {
            setTimeout(() => {
              observer.next('üçé'.repeat(number));
              observer.complete();
            }, 1000);
          } else {
            observer.next('üçé'.repeat(number));
            observer.complete();
          }
        })
    )
  )
  .subscribe(
    (value) => console.log(`The next value is: ${value}`),
    (error) => console.error(`There is an error: ${error}`)
  );

// Output
// ======
// The next value is: üçéüçé
// The next value is: üçéüçéüçé
// The next value is: üçé
// There is an error: No existences
</textarea>

<p>
  En este ejemplo tenemos un Observable que emite n√∫meros, y por cada n√∫mero tenemos otro observable que nos emite
  tantas manzanas como diga ese n√∫mero. En el momento que hay un error en cualquiera de los Observables este se emite al
  subscriptor y todos los Observables pendientes se cancelan.
</p>

<p>
  Primero se emite el elemento n√∫mero 1. Este elemento crea un Observable que emitir√° una manzana pasado un segundo. A
  continuaci√≥n se emite el elemento n√∫mero 2. Este se resuelve inmediatamente y se entrega al subscriptor. Lo mismo con
  el elemento n√∫mero 3. Despu√©s se recibe el elemento n√∫mero 0 que emitir√° un error pasado un segundo. Finalmente al
  cabo de un segundo el elemento n√∫mero 1 se resuelve y despu√©s el error.
</p>

<p>
  A continuaci√≥n te dejo un simulador para que pruebes:
</p>

<svg appDemoContainer viewBox="0 0 850 640">
  <g appConveyorController transform="translate(50,490)" [button1]="controllerButtons[MAIN_O][0]"
    [button2]="controllerButtons[MAIN_O][1]" [button3]="controllerButtons[MAIN_O][2]"
    [button4]="controllerButtons[MAIN_O][3]" [button5]="controllerButtons[MAIN_O][4]"
    (onButtonClick)="onControllerButtonClick($event)">
  </g>

  <g transform="translate(260, 490)" appConveyorHorizontal [length]="403" [conveyorWorking$]="conveyorsWorking[MAIN_O]">
  </g>

  <g appSubscriber transform="translate(690,420)" [showSpeechBubble$]="speechBubble$"
    (onSubscribe$)="onSubscribe($event)"></g>

  <g appOperator transform="translate(420, 452)"></g>

  <g [attr.transform]="'translate('+(460 - (200*(MERGE.length/2)))+', 70)'">
    <g [attr.transform]="'translate('+200*i+',0)'" *ngFor="let M_ID of MERGE; let i = index;" @animationConveyor>
      <g appConveyorController [attr.transform]="'translate(25,0)'" [button1]="controllerButtons[M_ID][0]"
        [button2]="controllerButtons[M_ID][1]" [button3]="controllerButtons[M_ID][2]"
        [button4]="controllerButtons[M_ID][3]" [button5]="controllerButtons[M_ID][4]"
        (onButtonClick)="onControllerButtonClick($event)">
      </g>

      <g [attr.transform]="'translate(70, 120)'" appConveyorVertical [length]="203"
        [conveyorWorking$]="conveyorsWorking[M_ID]">
      </g>
    </g>
  </g>

  <g>
    <text *ngFor="let element of elementsInConveyor" [attr.x]="element.x" [attr.y]="element.y">{{element.value}}</text>
  </g>
</svg>