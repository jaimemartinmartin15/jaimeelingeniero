<div class="page-header">
  <h1 class="title">ExhaustMap</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/exhaustMap" target="_blank">rxjs exhaustMap ‚û°Ô∏è</a>
</div>

<p>
  Este operador coge cada uno de los elementos emitidos por un Observable fuente y devuelve un nuevo Observable por
  cada elemento, cuyos elementos emitidos ser√°n puestos de nuevo en el observable fuente y que ser√°n los que se entregen
  al suscriptor. Los elementos emitidos en el Observable fuente son ignorados si el Observable creado para el elemento
  anterior a√∫n no ha completado.
</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable, exhaustMap } from 'rxjs';

// This is the source observable
const hearts$ = new Observable<string>((subscriber) => {
  subscriber.next('üíú');
  setTimeout(() => subscriber.next('üíö'), 100);
  setTimeout(() => subscriber.next('‚ù§Ô∏è'), 200);
  setTimeout(() => subscriber.next('üèòÔ∏è'), 300);
});

// Use the pipe method to add operators
hearts$
  .pipe(
    exhaustMap(
      (heart) =>
        new Observable((subscriber) => {
          if (heart === 'üíú') {
            setTimeout(() => {
              subscriber.next('üçá');
              subscriber.complete();
            }, 150);
          } else if (heart === 'üíö') {
            subscriber.next('üçè');
            subscriber.complete();
          } else if (heart === '‚ù§Ô∏è') {
            setTimeout(() => {
              subscriber.next('üçì');
              subscriber.complete();
            }, 150);
          } else {
            subscriber.error(`No heart value: ${heart}`);
          }
        })
    )
  )
  .subscribe({
    next: (value) => console.log(`The next value is: ${value}`),
    error: (error) => console.error(`There is an error: ${error}`),
    complete: () => console.log('Completed'),
  });

// Output
// ======
// The next value is: üçá
// The next value is: üçì
</textarea>

<p>
  En este ejemplo tenemos un Observable que emite corazones de colores, y por cada coraz√≥n tenemos otro observable que
  nos emite una fruta del mismo color que el coraz√≥n.
</p>

<p>
  Primero se emite el coraz√≥n morado y se crea un Observable. Cuando pasen 150 milisegundos se emitir√°n unas uvas.
  Despu√©s pasan 100 milisegundos y se emite el coraz√≥n verde. Como el Observabable del coraz√≥n morado a√∫n no ha
  completado, el coraz√≥n verde se ignora y nunca se emitir√° una manzana. Pasan entonces 50 milisegundos m√°s y se emiten
  las uvas. Pasan otros 50 milisegundos y se emite el coraz√≥n rojo en el Observable fuente. Esto crear un nuevo
  Observable que emite una fresa pasados 150 milisegundos. Pasan 100 milisegundos y se emite la casa, que deber√≠a
  producir un error. Pero como el Observable del coraz√≥n rojo no ha completado, la casita se ignora.
</p>

<p>
  A continuaci√≥n te dejo un simulador para que pruebes:
</p>

<!-- TODO add demo -->