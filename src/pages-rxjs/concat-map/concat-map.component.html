<div class="page-header">
  <h1 class="title">ConcatMap</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/concatMap" target="_blank">rxjs concatMap ‚û°Ô∏è</a>
</div>

<p>
  Este operador coge cada uno de los elementos emitidos por un Observable fuente y devuelve, por orden, un nuevo
  Observable por cada elemento. Es decir, hasta que no se completa el nuevo Observable, no crea uno nuevo para el
  siguiente elemento en el Observable fuente. Los elementos del nuevo Observable son puestos en el Obsevable fuente
  y son entregados al suscriptor.
</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable, concatMap } from 'rxjs';

// This is the source observable
const hearts$ = new Observable<string>((subscriber) => {
  subscriber.next('üíú');
  setTimeout(() => subscriber.next('üíö'), 100);
  setTimeout(() => subscriber.next('‚ù§Ô∏è'), 200);
  setTimeout(() => subscriber.next('üèòÔ∏è'), 300);
});

// Use the pipe method to add operators
hearts$
  .pipe(
    concatMap(
      (heart) =>
        new Observable((subscriber) => {
          if (heart === 'üíú') {
            setTimeout(() => {
              subscriber.next('üçá');
              subscriber.complete();
            }, 150);
          } else if (heart === 'üíö') {
            subscriber.next('üçè');
            subscriber.complete();
          } else if (heart === '‚ù§Ô∏è') {
            setTimeout(() => {
              subscriber.next('üçì');
              subscriber.complete();
            }, 150);
          } else {
            subscriber.error(`No heart value: ${heart}`);
          }
        })
    )
  )
  .subscribe({
    next: (value) => console.log(`The next value is: ${value}`),
    error: (error) => console.error(`There is an error: ${error}`),
    complete: () => console.log('Completed'),
  });

// Output
// ======
// The next value is: üçá
// The next value is: üçè
// The next value is: üçì
// There is an error: No heart value: üèòÔ∏è
</textarea>

<p>
  En este ejemplo tenemos un Observable que emite corazones de colores, y por cada coraz√≥n tenemos otro observable que
  nos emite una fruta del mismo color que el coraz√≥n. En el momento que hay un error en cualquiera de los Observables
  este se emite al suscriptor y todos los Observables pendientes se cancelan.
</p>

<p>
  Ahora veamos los detalles. Primero se emite el coraz√≥n morado. Este crear√° un Observable que emitir√° unas uvas pasados
  150 milisegundos. Pasados 100 milisegundos, se emite el coraz√≥n verde. Como el Observable del coraz√≥n morado a√∫n no ha
  completado, se retrasa la creaci√≥n del Observable para el coraz√≥n verde. Pasan entonces 50 milisegundos y se emiten
  las uvas y se completa el Observable. En ese momento el Observable del coraz√≥n verde esta pendiente, as√≠ que se
  subscribe a √©l y emite inmediatamente una manzana y completa. Pasan 50 milisegundos m√°s y se emite el coraz√≥n rojo,
  que emitir√° pasados 150 milisegundos una fresa. Pasan 100 milisegundos y se emite la casa. Como el Observable del
  coraz√≥n rojo a√∫n no ha completado, se retrasa la creaci√≥n del nuevo Observable. Pasan 50 milisegundos m√°s y se emite
  la fresa y completa. El Observable pendiente de la casa entonces emite ahora el error.
</p>

<p>
  A continuaci√≥n te dejo un simulador para que pruebes:
</p>

<svg appDemoContainer viewBox="0 0 850 640">
  <g appConveyorController transform="translate(50,490)" [button1]="controllerButtons[MAIN_O][0]"
    [button2]="controllerButtons[MAIN_O][1]" [button3]="controllerButtons[MAIN_O][2]"
    [button4]="controllerButtons[MAIN_O][3]" [button5]="controllerButtons[MAIN_O][4]"
    (onButtonClick)="onControllerButtonClick($event)">
  </g>

  <g transform="translate(260, 490)" appConveyorHorizontal [length]="403" [conveyorWorking$]="conveyorsWorking[MAIN_O]">
  </g>

  <g appSubscriber transform="translate(690,420)" [showSpeechBubble$]="speechBubble$"
    (onSubscribe$)="onSubscribe($event)"></g>

  <g appOperator transform="translate(420, 452)"></g>

  <g [attr.transform]="'translate('+(460 - (200*CONCAT.length/2))+', 70)'" class="smooth-tranform-animation">
    <g [attr.transform]="'translate('+200*i+',0)'" *ngFor="let C_ID of CONCAT; let i = index;" @fadeInOut
      class="smooth-tranform-animation">
      <g appConveyorController [attr.transform]="'translate(25,0)'" [button1]="controllerButtons[C_ID][0]"
        [button2]="controllerButtons[C_ID][1]" [button3]="controllerButtons[C_ID][2]"
        [button4]="controllerButtons[C_ID][3]" [button5]="controllerButtons[C_ID][4]"
        (onButtonClick)="onControllerButtonClick($event)">
      </g>

      <g [attr.transform]="'translate(70, 120)'" appConveyorVertical [length]="203"
        [conveyorWorking$]="conveyorsWorking[C_ID]">
      </g>

      <g>
        <ng-container *ngFor="let element of elementsInConveyor">
          <text *ngIf="element.conveyorId === C_ID" x="90" [attr.y]="element.y">{{element.value}}</text>
        </ng-container>
      </g>
    </g>
  </g>

  <g>
    <ng-container *ngFor="let element of elementsInConveyor">
      <text *ngIf="element.conveyorId === MAIN_O || element.conveyorId === MAIN_S" [attr.x]="element.x"
        y="546">{{element.value}}</text>
    </ng-container>
  </g>
</svg>