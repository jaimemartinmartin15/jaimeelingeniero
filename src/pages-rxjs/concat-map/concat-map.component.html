<div class="page-header">
  <h1 class="title">ConcatMap</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/concatMap" target="_blank">rxjs concatMap 俱뫮잺</a>
</div>

<p>
  Este operador coge cada uno de los elementos emitidos por un Observable fuente y devuelve, por orden, un nuevo
  Observable por cada elemento. Es decir, hasta que no se completa el nuevo Observable, no crea uno nuevo para el
  siguiente elemento en el Observable fuente. Los elementos del nuevo Observable son puestos en el Obsevable fuente
  y son entregados al subscriptor.
</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable, concatMap } from 'rxjs';

// This is the source observable
const numbers$ = new Observable<number>((observer) => {
  observer.next(1);
  observer.next(2);
  observer.next(0);
  observer.next(3);
});

// Use the pipe method to add operators
numbers$
  .pipe(
    concatMap(
      (number) =>
        new Observable((observer) => {
          if (number === 0) {
            setTimeout(() => {
              observer.error('No existences');
            }, 1000);
          } else if (number == 1) {
            setTimeout(() => {
              observer.next('游꼝'.repeat(number));
              observer.complete();
            }, 1000);
          } else {
            observer.next('游꼝'.repeat(number));
            observer.complete();
          }
        })
    )
  )
  .subscribe(
    (value) => console.log(`The next value is: ${value}`),
    (error) => console.error(`There is an error: ${error}`)
  );

// Output
// ======
// The next value is: 游꼝
// The next value is: 游꼝游꼝
// There is an error: No existences
</textarea>

<p>
  En este ejemplo tenemos un Observable que emite n칰meros, y por cada n칰mero tenemos otro observable que nos emite
  tantas manzanas como diga ese n칰mero. En el momento que hay un error en cualquiera de los Observables este se emite al
  subscriptor.
</p>

<p>
  Primero se emite el elemento n칰mero 1. Entonces se crea un nuevo observable y al cabo de un segundo se emite una
  manzana. A continuaci칩n se emite el elemento n칰mero 2, pero las dos manzanas no ser치n entregadas hasta que se emita la
  primera manzana, porque hasta que no complete el primer Observable, no se subcribe al siguiente. Lo mismo pasa con el
  elemento n칰mero 0. Hasta que no se emita la primera manzana y luego las otras dos, no se producir치 el error. Al
  Observable creado por el elemento n칰mero 3 no se llegar치 a subscribir ni emitir las tres manzanas, porque antes se
  producir치 el error con el elemento n칰mero 0.
</p>

<p>
  A continuaci칩n te dejo un simulador para que pruebes:
</p>

<svg appDemoContainer viewBox="0 0 850 640">
  <g appConveyorController transform="translate(50,490)" [button1]="controllerButtons[MAIN_M][0]"
    [button2]="controllerButtons[MAIN_M][1]" [button3]="controllerButtons[MAIN_M][2]"
    [button4]="controllerButtons[MAIN_M][3]" [button5]="controllerButtons[MAIN_M][4]"
    (onButtonClick)="onControllerButtonClick($event)">
  </g>

  <g transform="translate(260, 490)" appConveyorHorizontal [length]="403" [conveyorWorking$]="conveyorsWorking[MAIN_M]">
  </g>

  <g appSubscriber transform="translate(690,420)" [showSpeechBubble$]="speechBubble$"
    (onSubscribe$)="onSubscribe($event)"></g>

  <g appOperator transform="translate(420, 452)"></g>

  <g [attr.transform]="'translate('+(485 - (100*CONCAT.length))+', 70)'">
    <g [attr.transform]="'translate('+(200*i) +',0)'" *ngFor="let M_ID of CONCAT; let i = index;">
      <g appConveyorController [attr.transform]="'translate(0,0)'" [button1]="controllerButtons[M_ID][0]"
        [button2]="controllerButtons[M_ID][1]" [button3]="controllerButtons[M_ID][2]"
        [button4]="controllerButtons[M_ID][3]" [button5]="controllerButtons[M_ID][4]"
        (onButtonClick)="onControllerButtonClick($event)">
      </g>

      <g [attr.transform]="'translate(45, 120)'" appConveyorVertical [length]="203"
        [conveyorWorking$]="conveyorsWorking[M_ID]">
      </g>
    </g>
  </g>

  <g>
    <text *ngFor="let element of elementsInConveyor" [attr.x]="element.x" [attr.y]="element.y">{{element.value}}</text>
  </g>
</svg>