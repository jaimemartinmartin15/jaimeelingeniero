<div class="page-header">
    <h1>Observable</h1>
    <a class="link-rxjs" href="https://rxjs.dev/guide/observable" target="_blank">rxjs observable ‚û°Ô∏è</a>
</div>

<p>
    ¬øQu√© es un Observable? Voy a explicarte qu√© es un Observable con manzanas üçé.
</p>

<p>
    Imag√≠nate que un Observable es una cinta transportadora que emite frutas (datos). T√∫ te pones al final llamando al
    m√©todo subscribe y le pasas una callback (<span class="next">next</span>), una callback
    (<span class="error">error</span>) y una callback (<span class="complete">complete</span>) que se invocan
    cuando la fruta llega al final (<span class="next">next</span>), cuando viene otra cosa que no es una fruta
    (<span class="error">error</span>), o cuando la cinta se para (<span class="complete">complete</span>).
</p>

<p>
    Entre medias (el pipe) estan los operadores que pueden manipular esas frutas, pero los veremos en otras secciones.
</p>

<p>Veamos un primer ejemplo, uno sencillo:</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable } from 'rxjs';

const myFirstObservable = new Observable(observer => {
    doSomeStuff();
    observer.next('üçé'); // will invoke next callback passed in the subscribe method
    doOtherSuff();
    observer.next('üçé');
    observer.complete(); // will invoke complete callback passed in the subscribe method
});

// the callback function passed to the observable is not executed until we subscribe
myFirstObservable.subscribe(
    value => console.log(`The next value is: ${value}`),
    error => console.log(`Error: ${error}`),
    () => console.log('The observable has completed')
);

// Output
// ======
// The next value is: üçé
// The next value is: üçé
// The observable has completed
</textarea>

<p>
    Cuando creamos un objeto de tipo Observable con la palabra reservada new, le tenemos que
    pasar una funcion que toma un par√°metro: el observador.
</p>

<p>
    Lo bueno de esta funci√≥n es que puede "devolver" varios resultados llamando al m√©todo <span class="next">next</span>
    del observador.
    Cuando ha devuelto todos los valores el Observable se completa y ya no volver√° a emitir m√°s valores. Igual si
    el observable emite un error, ya no se devuelven m√°s valores:
</p>

<textarea highlight-js [lang]="'typescript'">
new Observable((subscriber) => {
    setTimeout(() => observer.next('This is timeout üçä'), 10); // it won't emit
    observer.next('üçé');
    observer.next('üçê');
    observer.error('üöó');
    console.log('This code still is executed: üçì');
    observer.next('üçç'); // it won't emit
})
.subscribe(
    fruit => console.log(`Next: ${fruit}`),
    error => console.log(`Error: ${fruit}`),
    () => console.log('Observable completed')
);

// Output
// ======
// Next: üçé
// Next: üçê
// Error: üöó
// This code still is executed: üçì
</textarea>

<p>
    Aunque por m√°s que llamemos a m√°s m√©todos del observador (next, error o complete) este no emitir√° eventos y las
    funciones callback del subscribe no se ejecutar√°n, porque el Observable ha completado o emitido un error.
</p>

<p>
    A continuaci√≥n te dejo un simulador para que pruebes:
</p>

<app-demo-container class="demo-container">
    <app-conveyor-controller class="conveyor-controller" [button1]="{value: 'üöó', type: ObservableEventType.ERROR}"
        [button2]="{value: 'üñêÔ∏è', type: ObservableEventType.COMPLETE}"
        [button3]="{value: 'üçå', type: ObservableEventType.NEXT}"
        [button4]="{value: 'üçç', type: ObservableEventType.NEXT}"
        [button5]="{value: 'üçé', type: ObservableEventType.NEXT}" (onButtonClick)="onControllerButtonClick($event)">
    </app-conveyor-controller>

    <app-conveyor-horizontal class="conveyor" [conveyorWorking$]="conveyorWorking$" [addToConveyor$]="addToConveyor$"
        (elementDelivered)="onEventDelivered($event)">
    </app-conveyor-horizontal>

    <app-subscriber class="subscriber" [showSpeechBubble$]="speechBubble$" (onSubscribe$)="onSubscribe($event)">
    </app-subscriber>
</app-demo-container>