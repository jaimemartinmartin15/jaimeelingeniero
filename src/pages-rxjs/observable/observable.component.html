<div class="page-header">
    <h1 class="title">Observable</h1>
    <a class="link-rxjs" href="https://rxjs.dev/guide/observable" target="_blank">rxjs observable ‚û°Ô∏è</a>
</div>

<p>
    ¬øQu√© es un Observable? Voy a explicarte qu√© es un Observable con manzanas üçé.
</p>

<p>
    Imag√≠nate que un Observable es una cinta transportadora que emite frutas (datos). T√∫ te pones al final llamando al
    m√©todo subscribe y le pasas una callback (<span class="next">next</span>), una callback
    (<span class="error">error</span>) y una callback (<span class="complete">complete</span>) que se invocan
    cuando la fruta llega al final (<span class="next">next</span>), cuando viene otra cosa que no es una fruta
    (<span class="error">error</span>), o cuando la cinta se para (<span class="complete">complete</span>).
</p>

<p>
    Entre medias (el pipe) estan los operadores que pueden manipular esas frutas, pero los veremos en otras secciones.
</p>

<p>Veamos un primer ejemplo, uno sencillo:</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable } from 'rxjs';

const myFirstObservable = new Observable(observer => {
    doSomeStuff();
    observer.next('üçé'); // will invoke next callback passed in the subscribe method
    doOtherSuff();
    observer.next('üçé');
    observer.complete(); // will invoke complete callback passed in the subscribe method
});

// the callback function passed to the observable is not executed until we subscribe
myFirstObservable.subscribe(
    value => console.log(`The next value is: ${value}`),
    error => console.log(`Error: ${error}`),
    () => console.log('The observable has completed')
);

// Output
// ======
// The next value is: üçé
// The next value is: üçé
// The observable has completed
</textarea>

<p>
    Cuando creamos un objeto de tipo Observable con la palabra reservada new, le tenemos que
    pasar una funcion que toma un par√°metro: el observador.
</p>

<p>
    Lo bueno de esta funci√≥n es que puede "devolver" varios resultados llamando al m√©todo <span class="next">next</span>
    del observador.
    Cuando ha devuelto todos los valores el Observable se completa y ya no volver√° a emitir m√°s valores. Igual si
    el observable emite un error, ya no se devuelven m√°s valores:
</p>

<textarea highlight-js [lang]="'typescript'">
new Observable((subscriber) => {
    setTimeout(() => observer.next('This is timeout üçä'), 10); // it won't emit
    observer.next('üçé');
    observer.next('üçê');
    observer.error('üöó');
    console.log('This code still is executed: üçì');
    observer.next('üçç'); // it won't emit
})
.subscribe(
    fruit => console.log(`Next: ${fruit}`),
    error => console.log(`Error: ${fruit}`),
    () => console.log('Observable completed')
);

// Output
// ======
// Next: üçé
// Next: üçê
// Error: üöó
// This code still is executed: üçì
</textarea>

<p>
    Aunque por m√°s que llamemos a m√°s m√©todos del observador (next, error o complete) este no emitir√° eventos y las
    funciones callback del subscribe no se ejecutar√°n, porque el Observable ha completado o emitido un error.
</p>

<p>
    A continuaci√≥n te dejo un simulador para que pruebes:
</p>

<svg appDemoContainer viewBox="0 0 640 240">
    <g transform="translate(20, 100)" appConveyorController [button1]="controllerButtons[0]"
        [button2]="controllerButtons[1]" [button3]="controllerButtons[2]" [button4]="controllerButtons[3]"
        [button5]="controllerButtons[4]" (onButtonClick)="onControllerButtonClick($event)">
    </g>

    <g transform="translate(210, 100)" appConveyorHorizontal [conveyorWorking$]="conveyorWorking$" [length]="250.8">
    </g>

    <g transform="translate(496, 20)" appSubscriber [showSpeechBubble$]="speechBubble$" 
        (onSubscribe$)="onSubscribe($event)">
    </g>

    <g>
        <text *ngFor="let element of elementsInConveyor" [attr.x]="element.x"
            [attr.y]="element.y">{{element.value}}</text>
    </g>
</svg>