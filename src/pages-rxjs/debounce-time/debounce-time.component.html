<div class="page-header">
    <h1 class="title">DebounceTime</h1>
    <a class="link-rxjs" href="https://rxjs.dev/api/operators/debounceTime" target="_blank">rxjs debounceTime ➡️</a>
</div>

<p>
    Este operador espera un tiempo para emitir los elementos del Observable fuente al suscriptor. Si pasado ese tiempo,
    no se emiten otros elementos, se emite al suscriptor. Si llega otro elemento, el previo se descarta y se reinicia el
    contador.
</p>

<textarea highlight-js [lang]="'typescript'">
import { debounceTime, Observable } from 'rxjs';

new Observable((suscriptor) => {
  setTimeout(() => suscriptor.next('🍎'), 100);
  setTimeout(() => suscriptor.next('🍌'), 300);
  setTimeout(() => suscriptor.next('🍇'), 850);
  setTimeout(() => suscriptor.next('🍓'), 1000);
  setTimeout(() => suscriptor.next('🍊'), 1450);
})
.pipe(debounceTime(500))
.subscribe({
  next: (value) => console.log(`The next value is: ${value}`),
  error: (error) => console.error(`There is an error: ${error}`),
  complete: () => console.log('Completed'),
});

// Output
// The next value is: 🍌
// The next value is: 🍊
</textarea>

<p>
    Expliquemos el ejemplo. Primero se emite la 🍎. Entonces se inicia el contador a 500 milisegundos que es lo que le
    pasamos al operador. Pasados 200 milisegundos se emite el 🍌. Como el contador no había llegado a cero, la 🍎 se
    descarta y se reinicia el contador a 500 otra vez. Estos 500 milisegundos pasan sin emitirse mas elementos, por lo
    que se emite el 🍌 al suscriptor. Después de los 500 milisegundos pasan otros 50 y se emiten las 🍇. En este momento
    el contador se vuelve a reiniciar siempre a 500 milisegundos. Pero antes de que llegue a cero, se emite la 🍓 y el
    contador se reinicia, descartando emitir las 🍇 al suscriptor. Pasan 450 milisegundos más y se emite la 🍊. El
    contador se reinicia y la 🍓 se descarta. Como no se vuelven a emitir más elementos pasados 500 milisegundos, se
    emite la 🍊.
</p>

<p>Prúebalo en esta demo, donde el debounceTime es de 1 segundo:</p>